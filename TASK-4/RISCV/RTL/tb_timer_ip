`timescale 1ns/1ps

module tb_timer_ip;

    // --------------------------------------------------
    // Clock & Reset
    // --------------------------------------------------
    reg sys_clk;
    reg rst_n;

    // --------------------------------------------------
    // Bus Interface
    // --------------------------------------------------
    reg         bus_sel;
    reg         bus_wr;
    reg [31:0]  bus_addr;
    reg [31:0]  bus_wdata;
    wire [31:0] bus_rdata;

    // --------------------------------------------------
    // Output
    // --------------------------------------------------
    wire timer_irq;

    // --------------------------------------------------
    // Register offsets
    // --------------------------------------------------
    localparam TMR_CFG     = 32'h10;
    localparam TMR_RELOAD  = 32'h14;
    localparam TMR_COUNT   = 32'h18;
    localparam TMR_STATUS  = 32'h1C;

    // --------------------------------------------------
    // DUT
    // --------------------------------------------------
    timer_ip dut (
        .sys_clk    (sys_clk),
        .rst_n      (rst_n),
        .bus_sel   (bus_sel),
        .bus_wr    (bus_wr),
        .bus_addr  (bus_addr),
        .bus_wdata (bus_wdata),
        .bus_rdata (bus_rdata),
        .timer_irq (timer_irq)
    );

    // --------------------------------------------------
    // Clock generation (100 MHz)
    // --------------------------------------------------
    always #5 sys_clk = ~sys_clk;

    // --------------------------------------------------
    // VCD dump (GTKWave)
    // --------------------------------------------------
    initial begin
        $dumpfile("TIMER.vcd");     // VCD file name
        $dumpvars(0, tb_timer_ip);     // dump everything
        //$dumpvars(1, dut);           // (optional) only DUT
    end

    // --------------------------------------------------
    // Bus write task
    // --------------------------------------------------
    task bus_write(input [31:0] addr, input [31:0] data);
    begin
        @(posedge sys_clk);
        bus_sel   <= 1'b1;
        bus_wr    <= 1'b1;
        bus_addr  <= addr;
        bus_wdata <= data;
        @(posedge sys_clk);
        bus_sel   <= 1'b0;
        bus_wr    <= 1'b0;
        bus_addr  <= 32'd0;
        bus_wdata <= 32'd0;
    end
    endtask

    // --------------------------------------------------
    // Bus read task
    // --------------------------------------------------
    task bus_read(input [31:0] addr);
    begin
        @(posedge sys_clk);
        bus_sel  <= 1'b1;
        bus_wr   <= 1'b0;
        bus_addr <= addr;
        @(posedge sys_clk);
        bus_sel  <= 1'b0;
        bus_addr <= 32'd0;
    end
    endtask

    // --------------------------------------------------
    // Test sequence
    // --------------------------------------------------
    initial begin
        sys_clk    = 0;
        rst_n      = 0;
        bus_sel   = 0;
        bus_wr    = 0;
        bus_addr  = 0;
        bus_wdata = 0;

        // Reset
        #30;
        rst_n = 1;

        // ---------------- ONE-SHOT MODE ----------------
        $display("\n--- One-shot mode test ---");
        bus_write(TMR_RELOAD, 32'd10);
        bus_write(TMR_CFG,    32'b01);

        repeat (15) @(posedge sys_clk);

        // ---------------- PERIODIC MODE ----------------
        $display("\n--- Periodic mode test ---");
        bus_write(TMR_RELOAD, 32'd5);
        bus_write(TMR_CFG,    32'b11);

        repeat (30) @(posedge sys_clk);

        // Read back
        bus_read(TMR_COUNT);
        bus_read(TMR_STATUS);

        #50;
        $display("\nSimulation finished");
        $finish;
    end

    // --------------------------------------------------
    // Monitor
    // --------------------------------------------------
    always @(posedge sys_clk) begin
        if (timer_irq)
            $display("Time %0t ns : TIMER IRQ ASSERTED", $time);
    end

endmodule

